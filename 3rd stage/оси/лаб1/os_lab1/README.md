# Отчет по лабораторной работе №1

---

## Выполнил:
    Батманов Даниил P3307

## Принял:
    Бойко Владислав Алексеевич

## Вариант:
    Linux	vfork	io-thpt-read	dedup	16K

---

##### Задание Часть 1. Реализация командной оболочки
Необходимо реализовать собственную оболочку командной строки - shell. Выбор ОС для реализации производится на усмотрение студента. Shell должен предоставлять пользователю возможность запускать программы на компьютере с переданными аргументами командной строки и после завершения программы показывать реальное время ее работы (подсчитать самостоятельно как «время завершения» – «время запуска»).

**Описание реализации**
- Я реализовал оболочку командной строки, используя `fork()` **(т.к. использование `vfork` на MacOS невозможно, потому что `vfork()`, из опыта Apple, является потенциально опасным и сложным для разработки, поэтому в современных версиях macOS этот вызов был исключен)** для создания нового процесса и `execvp()` для замены текущего процесса новым
- После завершения каждого процесса, оболочка фиксирует время завершения программы и рассчитывает общее время выполнения как разницу между временем запуска и временем завершения процесса
- Операционная система: `MacOS` (13.0 (22A380))

**Пример запуска программы в оболочке:**
```shell
./dedup 1000 100
```

**Результат:**
```
Total time for deduplication: 17 ms
Execution time: 26 ms
Program exited with code: 0
```

---

#### Задание Часть 2. Мониторинг и профилирование
Разработать комплекс программ-нагрузчиков по варианту, заданному преподавателем. Каждый нагрузчик должен, как минимум, принимать параметр, который определяет количество повторений для алгоритма, указанного в задании. Программы должны нагружать вычислительную систему, дисковую подсистему или обе подсистемы сразу. Необходимо скомпилировать их без опций оптимизации компилятора.

Перед запуском нагрузчика, попробуйте оценить время работы вашей программы или ее результаты (если по варианту вам досталось измерение чего либо). Постарайтесь обосновать свои предположения. Предположение можно сделать, основываясь на свой опыт, знания ОС и характеристики используемого аппаратного обеспечения.

- Запустите программу-нагрузчик и зафиксируйте метрики ее работы с помощью инструментов для профилирования. Сравните полученные результаты с ожидаемыми. Постарайтесь найти объяснение наблюдаемому.
- Определите количество нагрузчиков, которое эффективно нагружает все ядра процессора на вашей системе. Как распределяются времена  USER%, SYS%, WAIT%, а также реальное время выполнения нагрузчика, какое количество переключений контекста (вынужденных и невынужденных) происходит при этом?
- Увеличьте количество нагрузчиков вдвое, втрое, вчетверо. Как изменились времена, указанные на предыдущем шаге? Как ведет себя ваша система?
- Объедините программы-нагрузчики в одну, реализованную при помощи потоков выполнения, чтобы один нагрузчик эффективно нагружал все ядра вашей системы. Как изменились времена для того же объема вычислений? Запустите одну, две, три таких программы.
- Добавьте опции агрессивной оптимизации для компилятора. Как изменились времена? На сколько сократилось реальное время исполнения программы нагрузчика?

**Описание программ-нагрузчиков:**
1. **Измерение пропускной способности на последовательную запись накопителя с размерами блока Block Size (16К)**
   - **Параметры запуска:** `/io-thpt-read <file_path (при отсутсвии файла создаст его)> <file_size_in_MB> <iterations>`
2. **Дедупликация элементов в массиве**
   - **Параметры запуска:** `./dedup <array_size> <iterations>`

### Предполагаемое время выполнения нагрузочных программ

---

```shell
dedup 10000000 100
```

### 1. **Анализ сложности программы**

#### Генерация массива (`generateArray`):
- Размер массива N = 10^7, где N — количество элементов.
- Генерация выполняется за **O(N)** (один проход по массиву).

#### Дедупликация массива (`deduplicateArray`):
- Используется `std::unordered_set` для проверки уникальности элементов.
- Вставка в `unordered_set` имеет среднюю сложность **O(1)**, но нужно обойти все элементы входного массива.
- Итак, один вызов `deduplicateArray` выполняется за **O(N)**.

#### Итерации:
- `deduplicateArray` вызывается I = 100 раз (количество итераций).
- Таким образом, общая сложность программы будет:
  **O(I * N)**

---

### 2. **Подставим параметры**

- **\( N = 10^7 \)** (размер массива).
- **\( I = 100 \)** (количество итераций).
- Каждая итерация обрабатывает массив размером 10^7.
- Итого, программа выполняет 10^7 * 100 = 10^9 элементарных операций на вставку и проверку.

---

### 3. **Оценка времени на одной операции**

Твой процессор **Intel Core i5** с тактовой частотой **2.3 ГГц**:
- Это означает **2.3 миллиарда тактов в секунду**.

Допустим, что:
1. Вставка и проверка уникальности в `unordered_set` в среднем требует **10 тактов** на элемент (консервативная оценка из-за обращений к памяти и хэш-функций).

Таким образом:
Время на обработку = Операции * Такт на операцию / Тактовая частота процессора

Подставляем:
Время на обработку = 10^9 * 10 / 2.3 * 10^9 ≈ **4.35 секунд**

---

### 4. **Учет дополнительного времени**

1. **Генерация массива** — выполняется один раз за O(N), что дает примерно:
   Генерация ≈ 10^7 * 1 / 2.3 * 10^9 ≈ 0.0043 секунд (4.3 мс)

2. **Память и кэширование** — при 10^7 элементов и вставке их в `unordered_set`, затраты могут быть выше из-за **промахов кэша** и обращений к памяти. Это добавляет небольшой, но значимый оверхед, который сложно строго оценить.

---

### 5. **Итоговая оценка**

- Основной цикл I = 100 раз по массиву размера N = 10^7:
   - Теоретическое время ≈ **4.35 секунд**.
- Генерация массива добавляет ≈ **4 мс**.
- Промахи кэша и память могут увеличить время до **5-7 секунд**.

Таким образом, **математически** код должен выполняться примерно за **5-7 секунд** на машине с указанной производительностью.

---

### 6. **Проверка на практике**

Если фактическое время выполнения значительно больше (например, больше 10 секунд), это может быть связано с:
1. **Промахами кэша** при работе с большими массивами.
2. **Аллокацией памяти**: `std::vector` и `std::unordered_set` могут тратить время на выделение памяти.
3. **Ограничением производительности процессора** из-за **троттлинга** или других фоновый процессов.

---

```shell
./io-thpt-read generated_file.bin 200 1000
```

С учетом характеристик диска:
- **Скорость записи:** **662 MB/s**
- **Скорость чтения:** **2256 MB/s**

---

### **1. Фаза 1: Генерация файла (200 MB)**
Объем данных для записи: **200 MB**.  
Скорость записи: **662 MB/s**.

Время записи файла:
Время записи = Объем данных / Скорость записи = 200 / 662 ≈ 0.302 секунд.

---

### **2. Фаза 2: Измерение пропускной способности (1000 блоков)**
#### Размер данных, читаемых за одну итерацию:
- Один блок: 16 KB = 16 / 1024 MB.
- \( 1000 \) итераций: \( 1000 \times 0.016 = 16 \, \text{MB}\).

Скорость чтения: **2256 MB/s**.

Время чтения данных:
Время чтения = Объем данных / Скорость чтения = 16 / 2256 ≈ 0.007 секунд.

---

### **3. Общая оценка**
#### С учетом rewind (`lseek`) для чтения файла объемом 200 MB:
Каждый полный цикл чтения файла (размер файла 200 MB) завершает итерацию с lseek.  
Для 1000 итераций чтения (цикл `read + lseek`):

Полное время чтения = 200 * 1000 / 2256 ≈ 88.8 секунд.

Общая оценка:
- Генерация файла: **0.302 секунд**.
- Чтение данных + rewind: **88.8 секунд**.

Общее время выполнения программы ≈ 89.1 секунд.

---

### **Уточнение:**
Пропускная способность чтения значительно выше, однако основное влияние оказывает большое количество итераций, включающих чтение файла и возврат курсора в начало (rewind).

